//UT-EID=am73676_sr39533


import java.util.*;
import java.util.concurrent.*;

public class PSort implements Callable<Void>{
	  public static ExecutorService threadPool = Executors.newCachedThreadPool();
	  int n;
	  public PSort(int A[], int begin, int end){
		  this.A = A;
		  this.begin = begin;
		  this.end = end;
	  }
	  int A[], begin, end, index;
	  
		public static void parallelSort(int[] A, int begin, int end){
			ExecutorService es = Executors.newSingleThreadExecutor();
			PSort start = new PSort(A, begin, end);
	    	Future<Void> s = threadPool.submit(start);
	        es.shutdown ();
	        start.threadPool.shutdown();
		  }
		
	  public Void call() {
	    try {
	    	int index = partition(A, begin, end);
		    if(end - begin < 4){
		    	int b = begin;
		    	int e = end;
		    	for(; b <= e; b++){
		    		int value = A[b+1];
		    		int j = b;
		    		while(j>=b && A[j] > value){
		    			A[j+1] = A[j];
		    			j = j - 1;
		    		}
		    		A[j+1] = value;		
		    	}
		    }
		    if (begin < index -1){
		    	PSort left = new PSort(A, begin, index-1);
		    	Future<Void> l = threadPool.submit(left);
		    	l.get();
		    	}
		    if (index > end){
		    	PSort right = new PSort(A, index, end);
		    	Future<Void> r = threadPool.submit(right);
		    	r.get();
		    }
	       return null;
	    } catch (Exception e) { System.err.println (e); return null;}
	  }

/*  public static void quickSort(int[] A, int begin, int end){
	    int index = partition(A, begin, end);
	    if(end - begin < 4){
	    	int b = begin;
	    	int e = end;
	    	for(b=b; b <= e; b++){
	    		int value = A[b+1];
	    		int j = b;
	    		while(j>=b && A[j] > value){
	    			A[j+1] = A[j];
	    			j = j - 1;
	    		}
	    		A[j+1] = value;		
	    	}
	    	return;
	    }
	    if (begin < index -1)
	    	quickSort(A, begin, index-1);
	    
	    if (index > end)
	    	quickSort(A, index, end);
	    return;
	 }
*/  
  public static int partition(int[] A, int begin, int end){
	  int pivot = A[(begin+end)/2]; 
	  int b = begin;
	  int e = end;
	  while(b <= e){
		  while(A[b] < pivot) b++;
		  while(A[e] > pivot) e--;
		  if(b <= e){
			  int temp = A[b];
			  A[b] = A[e];
			  A[e] = temp;
			  b++;
			  e--;
		  }
	  }
	  return b;
  }

}
