import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Garden {
	final Lock lock = new ReentrantLock();
	final Condition fourDug = lock.newCondition();
	final Condition maryHasShovel = lock.newCondition();
	final Condition newtonHasShovel = lock.newCondition();
	int holesDug = 0;
    int seedsFilled = 0;
    int holesFilled = 0;
	public Garden() {   }; 
	public void startDigging() {
		lock.lock();
		try{
			if(holesDug != 0){
				try {
					newtonHasShovel.await();
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

			}
			while((holesDug + 4 == seedsFilled) || (seedsFilled + 8 == holesFilled)){
				maryHasShovel.signal();
			}
		}
		finally{
			lock.unlock();
		}
	}; 
	public void doneDigging() {
		lock.lock();
		try{
			holesDug++;
		}
		finally{
			lock.unlock();
		}
		maryHasShovel.signal();
	}; 
	public void startSeeding() {
		
	};
	public void doneSeeding() {
		lock.lock();
		try{
			seedsFilled++;
		}
		finally{
			lock.unlock();
		}
	}; 
	public void startFilling() {
		try {
			newtonHasShovel.await();
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}; 
	public void doneFilling() {
		lock.lock();
		try{
			holesFilled++;
		}
		finally{
			lock.unlock();
		}
		newtonHasShovel.signal();
	}; 
 
    /*
    * The following methods return the total number of holes dug, seeded or 
    * filled by Newton, Benjamin or Mary at the time the methods' are 
    * invoked on the garden class. */
   public int totalHolesDugByNewton() {return holesDug;}; 
   public int totalHolesSeededByBenjamin() {return seedsFilled;}; 
   public int totalHolesFilledByMary() {return holesFilled;}; 
}
